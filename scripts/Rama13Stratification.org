#+TITLE: Compare mooring & chipod dT/dz
#+AUTHOR: Deepak Cherian
#+DATE: 02 Feb 2017

* Load data + functions

#+BEGIN_SRC ipython :session :exports both
%matplotlib inline
import numpy as np
import matplotlib as mpl
import matplotlib.pyplot as plt
import datetime as dt
import hdf5storage as hs
import seaborn as sns
from scipy.io import loadmat

mpl.rcParams['savefig.transparent'] = True
mpl.rcParams['figure.figsize'] = [6.5, 6.5]
mpl.rcParams['figure.dpi'] = 120
mpl.rcParams['axes.facecolor'] = 'None'

fname = '../RAMA13/new/526/input/dTdz_i.mat'

mat = hs.loadmat('../RAMA13/new/526/input/dTdz_i.mat')
Tz_i = mat['Tz_i'];
Tzi = np.squeeze(Tz_i['Tz12'])
TziTime = np.squeeze(Tz_i['time'])

mat = hs.loadmat('../RAMA13/new/526/input/dTdz_m.mat')
Tz_m = mat['Tz_m'];
Tzm = Tz_m['Tz'][0][0][0]
TzmTime = Tz_m['time'][0][0][0]
Szm = Tz_m['Sz'][0][0][0]
sTS = Tz_m['s_TS'][0][0][0]

Tzi[abs(Tzi)>5] = np.nan
Tzm[abs(Tzm)>5] = np.nan

#+BEGIN_SRC ipython :session :exports both
def find_approx(vec, value):
    ind = np.argmin(vec == value)
    return ind

def line45():
    plt.axis('square')
    plt.xlim(np.array([-1, 1])*np.max(np.abs(plt.xlim())))
    plt.ylim(np.array([-1, 1])*np.max(np.abs(plt.ylim())))
    plt.plot(plt.xlim(), plt.ylim(), color='gray')

def ScatterSameTimeInterval(t1, v1, t2, v2, hax=None, guidelines=True):
    import matplotlib.pyplot as plt
    import numpy as np

    v2interp = np.interp(t1, t2, v2)

    if ~(hax is None):
        hax = plt.gca()

    plt.axes(hax)
    hax.plot(v1, v2interp, '+');

    if guidelines:
        plt.axhline(0, axes=hax, color='gray')
        plt.axvline(0, axes=hax, color='gray')
        line45()
#+END_SRC

#+RESULTS:

* Compare dT/dz between mooring and chipod
#+BEGIN_SRC ipython :session :file /Users/dcherian/rama/scripts/images/mooring-chipod-dTdz.png :exports both
f, (ax1, ax2) = plt.subplots(1,2)
plt.axes(ax1)
ScatterSameTimeInterval(TzmTime, Tzm, TziTime, Tzi)
ax1.set_xlabel('Mooring dT/dz')
ax1.set_ylabel('χ-pod dT/dz')

ax2.hist(Tzm[~np.isnan(Tzm)], bins=100, normed=True, alpha=0.5,
         label='mooring')
ax2.hist(Tzi[~np.isnan(Tzi)], bins=100, normed=True, alpha=0.5,
         label='χ-pod')
ax2.set_ylim([0, 4])
ax2.set_xlim([-0.2, 0.2])
ax2.legend()
ax2.set_xlabel('dT/dz')
ax2.set_ylabel('pdf')

#+END_SRC

#+RESULTS:
[[file:/Users/dcherian/rama/scripts/images/mooring-chipod-dTdz.png]]

Seems like the χpod senses more temperature inversions; seems good.

The mooring sees higher temperature gradients on average but still some negative values. I'm surprised this happens with 10-min data. Salinity stratification is the obvious explanation.

* T-S relation from mooring - historical data

#+BEGIN_SRC ipython :session :file /Users/dcherian/rama/scripts/images/Tz-mooring-historical-RAMA13.png :exports both

mat = loadmat('../processed/rama12n90e.mat', squeeze_me=True, struct_as_record=False)

T1 = mat['T1']
T2 = mat['T2']

# interpolate temperature onto Salinity
# ScatterSameTimeInterval(T1.Stime, T1.S, T1.time, T1.T, guidelines=False)

TzHist = (T1.T - T2.T)/np.abs(T1.z - T2.z)

def dcHist(var, bins=100, **kwargs):
    import numpy as np
    sns.set_style('darkgrid')
    mpl.rcParams['figure.facecolor'] = 'None'
    #plt.hist(var[~np.isnan(var)], bins, **kwargs)
    sns.distplot(var[~np.isnan(var)], bins, norm_hist=True, **kwargs)

bins = np.linspace(-0.1, .3, num=100)
dcHist(TzHist, bins, kde=False, label='all data')
dcHist(Tzm,  bins, kde=False, label='RAMA13 15m')
limy = plt.ylim()

plt.boxplot(TzHist[~np.isnan(TzHist)], vert=False,
            notch=0, positions=[-4], widths=5)
plt.boxplot(Tzm[~np.isnan(Tzm)], vert=False,
            notch=0, positions=[-9], widths=5)


plt.ylim([-15, limy[1]])
plt.xlim([-0.05, 0.1])
plt.yticks(np.arange(0, 120, 20))
plt.legend()
plt.xlabel('dT/dz from mooring CTDs at 10m, 20m')

#+END_SRC

#+RESULTS:
[[file:/Users/dcherian/rama/scripts/images/Tz-mooring-historical-RAMA13.png]]


Looks pretty good, I say!

* dT/dz and dS/dz from historical data
** Filtering
As Emily pointed out, I should probably get rid of the daily cycle.
I think we should go further and look at high-frequency variability only. The rest is not really relevant for χ really.

#+BEGIN_SRC ipython :session :file /Users/dcherian/rama/scripts/images/high-pass-filter-dTdz-dSdz.png :exports both

def FindGaps(input):
    '''
    Finds and return valid index ranges for the input time series.
    Input:
          input - input time series
    Output:
          start - starting indices of valid ranges
          stop  - ending indices of valid ranges
    '''

    import numpy as np

    NotNans = np.double(~np.isnan(input))
    edges = np.diff(NotNans)
    start = np.where(edges == 1)[0]
    stop = np.where(edges == -1)[0]

    if start.size == 0 and stop.size == 0:
        start = np.array([0])
        stop = np.array([len(input)-1])

    else:
        start = start + 1
        if ~np.isnan(input[0]):
            start = np.insert(start, 0, 0)

        if ~np.isnan(input[-1]):
            stop = np.append(stop, len(input)-1)

    return start, stop

def smooth(x,window_len=11,window='hanning'):
    """smooth the data using a window with requested size.

    This method is based on the convolution of a scaled window with the signal.
    The signal is prepared by introducing reflected copies of the signal
    (with the window size) in both ends so that transient parts are minimized
    in the begining and end part of the output signal.

    input:
        x: the input signal
        window_len: the dimension of the smoothing window; should be an odd integer
        window: the type of window from 'flat', 'hanning', 'hamming', 'bartlett', 'blackman'
            flat window will produce a moving average smoothing.

    output:
        the smoothed signal

    example:

    t=linspace(-2,2,0.1)
    x=sin(t)+randn(len(t))*0.1
    y=smooth(x)

    see also:

    numpy.hanning, numpy.hamming, numpy.bartlett, numpy.blackman, numpy.convolve
    scipy.signal.lfilter

    TODO: the window parameter could be the window itself if an array instead of a string
    NOTE: length(output) != length(input), to correct this: return y[(window_len/2-1):-(window_len/2)] instead of just y.
    """

    if x.ndim != 1:
        raise ValueError("smooth only accepts 1 dimension arrays.")

    if x.size < window_len:
        raise ValueError("Input vector needs to be bigger than window size.")


    if window_len<3:
        return x


    if not window in ['flat', 'hanning', 'hamming', 'bartlett', 'blackman']:
        raise ValueError("Window is on of 'flat', 'hanning', 'hamming', 'bartlett', 'blackman'")

    s=np.r_[x[window_len-1:0:-1],x,x[-1:-window_len:-1]]
    #print(len(s))
    if window == 'flat': #moving average
        w=np.ones(window_len,'d')
    else:
        w=eval('np.'+window+'(window_len)')

    y=np.convolve(w/w.sum(), s, mode='valid')
    return y

def SpectralDensity(input, nsmooth=5):

    start, stop = FindLargestSegment(input)
    f, out = signal.periodogram(input[start:stop],
                                fs=1.0, window='hamming')
    out = smooth(out, window_len=nsmooth, window='flat')
    f = smooth(f, window_len=nsmooth, window='flat')

    return f, out

def FindLargestSegment(input):

    start, stop = FindGaps(input)
    GapLength = stop-start+1
    imax = np.argmax(GapLength)

    return start[imax], stop[imax]

def HighPassButter(input, freq):
    import scipy.signal as signal

    b, a = signal.butter(1, freq/(1/2), btype='high')
    start, stop = FindLargestSegment(input)

    return signal.lfilter(b, a, input[start:stop])

def HighPassAndPlot(input, CutoffFreq, titlestr=None):

    filtered = HighPassButter(input, CutoffFreq)

    f, InputSpec = SpectralDensity(input, 10)
    plt.loglog(f, InputSpec, label='input data')

    f, FiltSpec = SpectralDensity(filtered, 10)
    plt.loglog(f, FiltSpec, label='high pass')

    plt.axvline(CutoffFreq, color='gray', zorder=-20)
    plt.ylabel('Spectral density')
    plt.xlabel('Frequency')
    plt.title(titlestr)
    plt.legend()

SzHistHr = (T1.S-T2.S)/np.abs(T1.z-T2.z)
# interpolate 10 minute dT/dz to hourly time stamp like dS/dz
TzHistHr = np.interp(T1.Stime, T1.time, TzHist)

f, [ax1,ax2] = plt.subplots(2,1, sharex='all')
plt.axes(ax1)
HighPassAndPlot(TzHistHr, 1/6, titlestr='dT/dz')
plt.axvline(1/24, color='gray', zorder=-10) # cutoff frequency
plt.xlabel('')

plt.axes(ax2)
HighPassAndPlot(SzHistHr, 1/6, titlestr='dS/dz')
plt.axvline(1/24, color='gray', zorder=-10) # cutoff frequency
#+END_SRC

#+RESULTS:
[[file:/Users/dcherian/rama/scripts/images/high-pass-filter-dTdz-dSdz.png]]

Temperature has *strong* daily peak. Needs really strict filtering.
Salinity not so much.
** All times
#+BEGIN_SRC ipython :session :file /Users/dcherian/rama/scripts/images/dTdz-dSdz-RAMA13.png :exports both

def JointPlot(Tz, Sz, titlestr=None, **kwargs):
    g = sns.jointplot(Tz, Sz,  marker='.', **kwargs)
    g.set_axis_labels('dT/dz', 'dS/dz')
    ax = g.fig.get_axes()

    ax[0].axhline(0, color='gray')
    ax[0].axvline(0, color='gray')

    if titlestr:
        ax[1].set_title(titlestr)

JointPlot(TzHistHr, SzHistHr, titlestr='All data')

#+END_SRC

#+RESULTS:
[[file:/Users/dcherian/rama/scripts/images/dTdz-dSdz-RAMA13.png]]
1. S_z < 0 for the most part which makes sense.
2. S_z has larger magnitude when T_z < 0 which also makes sense.

** Divide into 4 seasons

#+BEGIN_SRC ipython :session :file /Users/dcherian/rama/scripts/images/dTdz-dSdz-seasons.png :exports both
def suplabel(axis,label,label_prop=None,
             labelpad=5,
             ha='center',va='center'):
    ''' Add super ylabel or xlabel to the figure
    Similar to matplotlib.suptitle
    axis       - string: "x" or "y"
    label      - string
    label_prop - keyword dictionary for Text
    labelpad   - padding from the axis (default: 5)
    ha         - horizontal alignment (default: "center")
    va         - vertical alignment (default: "center")
    '''
    import matplotlib.pyplot as plt
    fig = plt.gcf()
    xmin = []
    ymin = []
    for ax in fig.axes:
        xmin.append(ax.get_position().xmin)
        ymin.append(ax.get_position().ymin)
    xmin,ymin = min(xmin),min(ymin)
    dpi = fig.dpi
    if axis.lower() == "y":
        rotation=90.
        x = xmin-float(labelpad)/dpi
        y = 0.5
    elif axis.lower() == 'x':
        rotation = 0.
        x = 0.5
        y = ymin - float(labelpad)/dpi
    else:
        raise Exception("Unexpected axis: x or y")
    if label_prop is None:
        label_prop = dict()
    plt.text(x,y,label,rotation=rotation,
               transform=fig.transFigure,
               ha=ha,va=va, **label_prop)

def datenum2datetime(matlab_datenum):
    from matplotlib.dates import num2date

    python_datetime = num2date(matlab_datenum-367)

    return python_datetime


def ReturnSeason(time, var, season):
    ''' Given a season, return data only for the months in that season
        season can be one of SW, NE, SW->NE or NE->SW
    '''
    dates = datenum2datetime(time)
    months = [d.month for d in dates]

    seasonMonths = { 'SW' :  [5,6,7,8,9],
                     'SW→NE' : [10, 11],
                     'NE' :  [12,1,2],
                     'NE→SW' : [3,4], }

    mask = np.asarray([m in seasonMonths[season] for m in months])

    return time[mask], var[mask]

f, hax = plt.subplots(2,2, sharex=True, sharey=True)
hax = hax.ravel()

for idx,season in enumerate(['SW', 'SW→NE', 'NE', 'NE→SW']):
    time,Tz = ReturnSeason(T1.Stime, TzHistHr, season)
    time,Sz = ReturnSeason(T1.Stime, SzHistHr, season)

    sns.regplot(Tz, Sz, ax=hax[idx], ci=None, marker='.');
    hax[idx].axhline(0, color='gray')
    hax[idx].axvline(0, color='gray')
    hax[idx].set_title(season)
    hax[idx].set_xlim([-0.1, 0.25])
    hax[idx].set_ylim([-0.15, 0.05])

label_prop=dict(fontsize=14)
suplabel('y', 'dS/dz', labelpad=15, label_prop=label_prop)
suplabel('x', 'dT/dz', labelpad=8, label_prop=label_prop)
f.suptitle('RAMA 12N 90E, 15m - all data (hourly)')
#+END_SRC

#+RESULTS:
[[file:/Users/dcherian/rama/scripts/images/dTdz-dSdz-seasons.png]]

During the SW & NE monsoons, There is a tight cluster of points, relatively speaking.
NE -> SW monsoon seems worst.
