#+TITLE: RAMA: χ estimates
#+AUTHOR: Deepak Cherian
#+DATE: 14 Mar 2017

#+OPTIONS: html-link-use-abs-url:nil html-postamble:auto
#+OPTIONS: html-preamble:t html-scripts:nil html-style:nil
#+OPTIONS: html5-fancy:t tex:t broken-links:mark H:5
#+HTML_DOCTYPE: html5
#+HTML_CONTAINER: div
#+LATEX_CLASS: dcnotebook
#+HTML_HEAD: <link rel="stylesheet" href="notebook.css" type="text/css" />

* generic :noexport:
#+BEGIN_SRC ipython :session
%matplotlib inline

import numpy as np
import matplotlib as mpl
import matplotlib.pyplot as plt
import importlib
import datetime as dt
import bottleneck as bn
import h5py

import dcpy.ts
import dcpy.plots
import dcpy.util

import chipy.chipy as chipy
import moor.moor as moor
#+END_SRC

#+RESULTS:
* Map
#+CAPTION: χpod locations for ASIRI/EBOB/MesoBOB
[[file:~/ebob/MixingmapASIRIPiston.png]]

* RAMA13 (ra-107)
|------------+------------+-----------------+----------------+------+---------|
| Section    | Dir        | Vel             | S              | Tz   | Compass |
|------------+------------+-----------------+----------------+------+---------|
| [[first try]]  | [[file:RAMA13/data/526/proc/first-try][first-try]]  | both            | daily          | both | ?       |
| [[2017-04-07]] | [[file:RAMA13/data/526/proc/2017-04-07][2017-04-07]] | mooring         | 10m (pre-cal?) | off  | off     |
|            | ---------- | changed masking | -------------- |      |         |
| [[2017-04-12]] | [[file:~/rama/RAMA13/data/526/proc/2017-04-12][2017-04-12]] | mooring         | 10m (filt)     | both | off     |
|            | ---------- | N² tanh fit     | -------------- |      |         |
| [[2017-04-20]] |            | mooring         | N² fit         | both | off     |
|------------+------------+-----------------+----------------+------+---------|

Notes on above:
- Unsure what salinity I used for 2017-04-07. The big difference between that and 2017-04-12 is the N² time series. N^2 drift screws up χ estimate

- Very sure that 2017-04-12 used hourly filtered 10min salinity.
** full mooring

1. Looks like dS/dz is as important as dT/dz in N².
2. For *30m* χpod, using *10m* mooring velocity instead of pitot makes basically no difference.

#+CAPTION: Not recreating Sally's Hudhud results exactly; but very close. +Could be different N²+ My salinity & hence N² is at 10min resolution (noisier); hers is daily!
[[file:images/cyclone-jq-sally-me.png]]

Try a stacked histogram like
[[file:~/work/good-vis/joyplot.jpeg]]
or
[[file:~/work/good-vis/joyplot2.jpeg]]
#+BEGIN_SRC ipython :session :file images/temp/py3052_Zd.png
pod = ra12.χpod[526];
self = pod;
varname = 'KT'
est = 'best'

var, titlestr, yscale, grdflag = self.ChooseVariable(varname, est)

ax = plt.gca()
from dcpy.util import ExtractSeason
import calendar
for mno, mmm in enumerate(calendar.month_abbr[1:]):
    t, v = ExtractSeason(self.time, var, mmm)

    if yscale == 'log':
        var = np.log10(abs(var))
        label = '$\log_{10}$(' + titlestr + ')'
    else:
        label = titlestr

    hist, edges = np.histogram(var[np.isfinite(var)],
                                  bins=40, density=True)
    hist = hist/hist.max()
    hist[hist < 0.05] = np.nan
    ax.plot((edges[:-1]+edges[1:])/2,
            hist + mon+1, color='gray')

ax.set_xlabel(label)
ax.set_yticks(range(1,13))
ax.set_yticklabels(calendar.month_abbr[1:])
ax.spines['left'].set_bounds(1, 12)
# limx = ax.get_xticks()
#ax.spines['bottom'].set_bounds(limx[1], limx[-2])
#+END_SRC

#+RESULTS:
[[file:images/temp/py3052_Zd.png]]


#+BEGIN_SRC ipython :session
%matplotlib inline

import moor.moor as moor
import chipy.chipy as chipy

importlib.reload(moor)
importlib.reload(chipy)

import os
if 'rama' not in os.getcwd():
    os.chdir('/home/deepak/rama/scripts/')

ra12 = moor.moor(90, 12, 'RAMA 12N | 2013', '../RAMA13/')
ra12.AddChipod(526, 15, 'mm', '2017-07-10.mat')
ra12.AddChipod(527, 30, 'mm', '2017-07-10.mat')
ra12.ReadMet('../RAMA13/rama_mooring_data/', WindType='pmel')
ra12.ReadCTD('../RamaPrelimProcessed/RAMA13.mat', 'ramaprelim')
ra12.AddSpecialTimes('Hudhud', '2014-Oct-08', '2014-Oct-11')
#+END_SRC

#+RESULTS:

#+BEGIN_SRC ipython :async t :session :file images/rama13-summary.png
importlib.reload(chipy)

filter_len = 3600*24
ax = ra12.Plotχpods(filter_len=filter_len)

ax[-3].set_ylim([1e-10, 1e-5])
ax[-1].set_ylim([-100, 100])
#+END_SRC
#+CAPTION: Daily averages of τ, N², J_q; daily running median of χ, K_T. min N² = 3e-6. Green is χ calculated with pitot velocity.
#+RESULTS:
[[file:images/rama13-summary.png]]
#+BEGIN_SRC ipython :session :file images/TS-rama13.png
dcpy.util = importlib.reload(dcpy.util)
ra12.TSPlot(varname='KT', varmin=1e-3, filter_len=3600*12)
#+END_SRC
#+CAPTION: TS plot for RAMA 12N (2013) - coloured by depth. S_max is at 60m generally, though sometimes it appears at 40m. High values of K_T are marked.
#+RESULTS:
[[file:images/TS-rama13.png]]

#+BEGIN_SRC ipython :session :file images/ra12-temp-spectra.png
import dcpy.ts
import numpy as np
import matplotlib.pyplot as plt
dcpy.ts = importlib.reload(dcpy.ts)

ticks = np.array([1/24, 1/12, 1/3, 12.42*3600/86400, 1, 2,
                  5, 10, 20, 60])*86400
# ax = ra12.χpod[526].PlotSpectrum('chi', filter_len=3600*12, nsmooth=3,
#                                  SubsetLength=20*86400, ticks=None)

breakpts = np.sort(1/np.array([30, 1, 0.33, 0.08, 0.02])/86400)
nsmooth = [2, 5, 12, 35, 120]

ra12.PlotSpectrum('T', filter_len=None, nsmooth=nsmooth,
                  breakpts=breakpts, SubsetLength=None,
                  ticks=ticks, norm=True)

plt.show()
#+END_SRC

#+RESULTS:
[[file:images/ra12-temp-spectra.png]]

#+BEGIN_SRC ipython :session :file images/ra12-spectra.png

dcpy.ts = importlib.reload(dcpy.ts)

ticks = np.array([1/2, 1, 2, 5, 10, 20, 30])*86400

# ra12.PlotAllSpectra(filter_len=3600, nsmooth=3,χpod[526].
#                    SubsetLength=13*86400, ticks=ticks)

# ra12.PlotSpectrum('χ', filter_len=3600*3, nsmooth=12,
#                   SubsetLength=None, ticks=ticks[2:-2])
ra12.PlotSpectrum('χ', filter_len=3600*12, nsmooth=4,
                  SubsetLength=None, ticks=ticks[:-2],
                  ax=plt.gca(), norm=True)
#+END_SRC

#+RESULTS:
[[file:images/ra12-spectra.png]]

#+BEGIN_SRC ipython :session :file images/rama12n-kt-boxplot.png
ra12.ChipodSeasonalSummary()
#+END_SRC

#+RESULTS:
[[file:images/rama12n-kt-boxplot.png]]

[[file:images/rama13-T-S-ρ.png]]

[[file:images/rama13-dens-diff-10m-dy.png]]

#+BEGIN_SRC ipython :session :file images/ra12n-winds.png
from scipy.interpolate import interpn

met = nc.MFDataset('../tropflux/tau_tropflux*')
lon = met['longitude'][:]
lat = met['latitude'][:]
time = met['time'][:]
latm = 12;
lonm = 90;
τtrop = interpn((time, lat, lon),
                met['tau'][:, :, :],
                (time, 12, 90))
ttrop = time \
        + dt.date2num(dt.datetime.date(1950, 1, 1))

plt.plot(ra12.met.τtime, ra12.met.τ)
plt.plot(ttrop, τtrop)
plt.plot(ra12.met.τtime, ra12.met.τ)
plt.xlim([ra12.met.τtime[0], ra12.met.τtime[-1]])
ax = plt.gca()
ax.xaxis_date()
ax.legend(['RAMA 12N', 'Tropflux daily'])
#+END_SRC
#+CAPTION: Let's compare tropflux winds with actual rama winds. Looks like spatial interpolation is working ok.
#+RESULTS:
[[file:images/ra12n-winds.png]]

*** datashader test :noexport:
#+BEGIN_SRC ipython :session    :file images/temp/py12159_Dn.png

# test out TS plot
import dcpy.oceans
import numpy as np

importlib.reload(dcpy.oceans)

S = ra12.ctd.sal.copy()
T = ra12.ctd.temp.copy()
P = np.tile(ra12.ctd.depth, [S.shape[1], 1]).T
assert(P.shape == S.shape)

import pandas as pd
df = pd.DataFrame(
    np.array([S.ravel(), T.ravel(), P.ravel()]).T,
    index=np.arange(S.ravel().shape[0]),
    columns=['S', 'T', 'P'])

# dcpy.oceans.TSplot(ra12.ctd.sal[0, :],
#                    ra12.ctd.temp[0, :],
#                    ra12.ctd.depth[0], 0)

import datashader as ds
import datashader.transfer_functions as tf
cvs = ds.Canvas(plot_height=400, plot_width=400)
agg = cvs.points(df, 'S', 'T', ds.mean('P'))
img = tf.shade(agg, cmap=['lightblue', 'darkblue'])
#+END_SRC

#+RESULTS:
** MISO signals?
#+BEGIN_SRC ipython :session
%matplotlib inline

import moor.moor as moor
import chipy.chipy as chipy

moor = importlib.reload(moor)
chipy = importlib.reload(chipy)

import os
if 'rama' not in os.getcwd():
    os.chdir('/home/deepak/rama/scripts/')

ra12 = moor.moor(90, 12, 'RAMA 12N | 2013', '../RAMA13/')
ra12.AddChipod(526, 15, 'mm', '2017-07-10.mat')
ra12.AddChipod(527, 30, 'mm', '2017-07-10.mat')
ra12.ReadMet('../RAMA13/rama_mooring_data/', WindType='pmel')
ra12.ReadCTD('../RamaPrelimProcessed/RAMA13.mat', 'ramaprelim')
ra12.AddSpecialTimes('Hudhud', '2014-Oct-08', '2014-Oct-11')
#+END_SRC

#+RESULTS:

#+BEGIN_SRC ipython :session :file images/rama13-summary-miso.png
filter_len = np.array([20, 60])*86400
dcpy.ts = importlib.reload(dcpy.ts)

ax = ra12.Plotχpods(filt='bandpass', filter_len=filter_len)
#+END_SRC

#+CAPTION: Band-pass filter looking for MISO signals. We don't lose edges when filtering J_q because it's a 3 year record from Tropflux. Looks like our 30m χpod is at a depth where the "mode structure" of subsurface temperature fluctuations has near-0 amplitude (at least while the instrument was alive - died in Sep-2014). Magnitude of temp anomaly fluctuations (1C) agrees with literature. Overlaid black contours are salinity fluctuations in the pass-band (dashed = negative).
#+RESULTS:
[[file:images/rama13-summary-miso.png]]

The next figure shows coherence between Jq0 and  Jqt at 15m, 30m at the RAMA 12N mooring for the year 2014. Signs for all fluxes are such that +ve warms the surface.
Looks like we have significant coherence in the 20-60day band between daily averaged Jq0 and Jqt at 15m.
The 180 phase difference looks stable, is apparent in the filtered time series and seems to make physical sense (more surface heating → increases T_z → reduces J_q^t and vice versa).

Nothing at 30m
 - short(er) data record - instrument dies in september
 - not much temp fluctuations at that depth while the instrument was alive (see above).

#+BEGIN_SRC ipython :session :file images/ra12-jq0-jqt-coherence.png
%matplotlib inline

moor = importlib.reload(moor)
chipy = importlib.reload(chipy)

import os
if 'rama' not in os.getcwd():
    os.chdir('/home/deepak/rama/scripts/')

ra12 = moor.moor(90, 12, 'RAMA 12N | 2013', '../RAMA13/')
ra12.AddChipod(526, 15, 'mm', '2017-07-10.mat')
ra12.AddChipod(527, 30, 'mm', '2017-07-10.mat')
ra12.ReadMet('../RAMA13/rama_mooring_data/', WindType='pmel')
ra12.ReadCTD('../RamaPrelimProcessed/RAMA13.mat', 'ramaprelim')
# ra12.AddSpecialTimes('Hudhud', '2014-Oct-08', '2014-Oct-11')

dcpy.util = importlib.reload(dcpy.util)
dcpy.ts = importlib.reload(dcpy.ts)
fbands = [1/90,  # 90 day resonance?
          1/(2*np.pi/dcpy.oceans.inertial(12)/86400),  # f_0
          AliasFreq(1/(12.42/24), 1), # M_2 alias
          1/12,
          1/2.15]
ax = ra12.PlotFluxCoherence(metvar='Jq', nsmooth=5, multitaper=True,
                            filt='bandpass', fbands=fbands,
                            filter_len=np.array([20, 60])*86400)
#+END_SRC
#+CAPTION: (Top left) Band-passed time series. (bottom left) PSD for the unfiltered time series. (Right) coherence amplitude and phase between J_q^0 and J_q^t at both depths. Significance level marked by horizontal line. Vertical lines are frequencies: 90 days, 14.7 day M_2 alias, 12 day peak, inertial period = 2.4 days, 2.1 day peak.
#+RESULTS:
[[file:images/ra12-jq0-jqt-coherence.png]]

** χ-pod 526
*** Spectra
**** Spectrogram

#+BEGIN_SRC ipython :session
χ = apr20.chi['mm']['chi']
χ[np.isnan(χ)] = 0

fs = np.round(86400/apr20.dt)  # samples/day
ndays = 7

TM2 = 12.42
Tf0 = 2*np.pi/sw.f(ra12.lat)
#+END_SRC

#+RESULTS:


#+BEGIN_SRC ipython :session    :file images/temp/py30956SXk.png
S, f, conf = SpectralDensity(χ, dt=1/fs, nsmooth=None)
plt.loglog(f, S)
plt.axvline(1/TM2, color='k', linewidth=0.5)
plt.axvline(1/Tf0, color='k', linewidth=0.5)
#+END_SRC

#+RESULTS:
[[file:images/temp/py30956SXk.png]]

#+CAPTION: spectrum of χ (gaps filled with 0)
#+RESULTS:

#+BEGIN_SRC ipython :session    :file images/temp/py30956fa2.png
from dcpy.ts import SpectralDensity
import scipy.signal as signal

f, t, Sxx = signal.spectrogram(χ, fs=fs,
                               nperseg=ndays*fs,
                               noverlap=ndays/2*fs)

# Sxx[Sxx < 1e-70] = np.nan
plt.pcolormesh(f, t, np.log10(Sxx.T))
plt.yscale('log')
plt.colorbar()
plt.clim([-30, -8.5])
plt.axhline(24/12.42)
#+END_SRC
#+CAPTION: Spectrogram
#+RESULTS:
[[file:images/temp/py30956fa2.png]]

**** Proto χ spectrum
#+CAPTION: [Unit 526, RAMA 12N, 15m] Testing out ~gappy_psd.m~ with different windows. I'm using daily or half-daily means and *filling in 2 day gaps*
[[file:images/526-chi-proto-spectra.png]]

#+CAPTION: spectrogram of temp with N² overlaid.
[[file:images/526-temp-spectrogram.png]]
*** Choosing Tz

#+BEGIN_SRC ipython :session    :file images/526-chi-change-Tz.png

  import dcpy.plots
  importlib.reload(dcpy.plots)

  pod = ra12.χpod[526]

  χ1 = pod.chi['mm1']['chi'][0]
  χ2 = pod.chi['mm2']['chi'][0]

  Tzm = pod.chi['mm1']['dTdz'][0]
  Tzi1 = pod.chi['mi11']['dTdz'][0]
  Tzi2 = pod.chi['mi22']['dTdz'][0]

  Ktm1 = 0.5 * χ1 / (Tzm**2)
  Ktm2 = 0.5 * χ2 / (Tzm**2)

  Kti1 = 0.5 * χ1 / (Tzi1**2)
  Kti2 = 0.5 * χ2 / (Tzi2**2)

  min_dTdz = 1e-3
  mask1 = abs(Tzi1) > min_dTdz;
  mask2 = abs(Tzi2) > min_dTdz;

  ax1 = plt.subplot(211)
  dcpy.plots.hist(Ktm1[mask1], log=True, label='m1')
  dcpy.plots.hist(Kti1[mask1], log=True, label='i1')
  plt.legend()

  plt.subplot(212, sharex=ax1)
  dcpy.plots.hist(Ktm2[mask2], log=True, label='m2')
  dcpy.plots.hist(Kti2[mask2], log=True, label='i2')
  plt.legend()
#+END_SRC
#+CAPTION: Use χ calculated with mooring N². Calculate K_T with different dT/dz
#+RESULTS:
[[file:images/526-chi-change-Tz.png]]
*** 2017-07-09

#+BEGIN_SRC ipython :session  :exports both
import chipy.chipy as chipy
import importlib
chipy = importlib.reload(chipy)

jul09 = chipy.chipod('../RAMA13/data/', '526', '2017-07-09.mat')
jul09.LoadChiEstimates()
jul09.LoadSallyChiEstimate('../sally/chi_analysis_bkgrnd_Feb5/deglitched/mean_chi_526_mindTdz3e-4.mat', 'sally')

apr20 = chipy.chipod('../RAMA13/data/', '526', '2017-04-20.mat')
apr20.LoadChiEstimates()
#+END_SRC

#+RESULTS:

Change in skew is because I was using smoothed T_z earlier I think.
#+BEGIN_SRC ipython :session :file images/temp/526-apr20-jul09.png
est = 'mm1'
plt.figure(figsize=(8, 3.5))
plt.subplot(141)
dcpy.plots.hist(apr20.chi[est]['chi'], log=True)
dcpy.plots.hist(jul09.chi[est]['chi'], log=True)
plt.title('$log_{10} χ$')

plt.subplot(142)
dcpy.plots.hist(apr20.chi[est]['eps'], log=True)
dcpy.plots.hist(jul09.chi[est]['eps'], log=True)
plt.title('$log_{10} ε$')

plt.subplot(143)
dcpy.plots.hist(apr20.KT[est], log=True)
dcpy.plots.hist(jul09.KT[est], log=True)
plt.title('K$ _T$')
plt.legend(('apr20', 'jul09'))

plt.subplot(144)
dcpy.plots.hist(apr20.Jq[est], log=True)
dcpy.plots.hist(jul09.Jq[est], log=True)
plt.title('$log_{10}|J_q|$')

plt.tight_layout()
plt.show()

#+END_SRC

#+RESULTS:
[[file:images/temp/526-apr20-jul09.png]]

#+BEGIN_SRC ipython :session  :file images/compare-sally-summary.png

est = 'mm1'
plt.figure(figsize=(8, 3.5))
plt.subplot(141)
dcpy.plots.hist(jul09.chi[est]['chi'], log=True)
dcpy.plots.hist(jul09.chi['sally1']['chi'], log=True)
plt.title('χ')

plt.subplot(142)
dcpy.plots.hist(jul09.KT[est], log=True)
dcpy.plots.hist(jul09.chi['sally1']['Kt1'], log=True)
plt.title('$K_T$')

plt.subplot(143)
dcpy.plots.hist(jul09.chi[est]['dTdz'], log=True)
dcpy.plots.hist(jul09.chi['sally1']['dTdz'], log=True)
plt.title('$|T_z|$')
plt.legend(('mine', 'sally'))

plt.subplot(144)
dcpy.plots.hist(jul09.Jq[est], log=True)
dcpy.plots.hist(jul09.chi['sally1']['Jq1'], log=True)
plt.title('$|J_q|$')

plt.tight_layout()
plt.show()
#+END_SRC

#+RESULTS:
[[file:images/compare-sally-summary.png]]

*** 2017-04-20

[[file:images/N2-fit.png]]

This estimate uses the tanh fit to determine N².
#+CAPTION: Tuned tanh fit used to determine N² compared against simple difference (~diff~)
[[file:images/N2-fit-compare.png]]

*K_T:* ~mm1~, ~mm2~ agree well; Similarly ~mi11~ and ~mi22~ agree well.

+But there's a bias when comparing ~mm1~ with ~mi11~.+
- Bias is "fixed" by using T-S relation from a mooring CTD sensor along with Tz_i somehow. See below.

- Tz_i is calculated over 10 minutes

- +I wonder if I should really fit salinity gradient instead of the backwards method I'm using currently.+

Read data:
#+BEGIN_SRC ipython :session  :exports both

import chipy.chipy as chipy
import importlib
chipy = importlib.reload(chipy)

apr20 = chipy.chipod('../RAMA13/data/', '526', '2017-04-20.mat')
apr20.LoadChiEstimates()
apr20.LoadSallyChiEstimate('../sally/chi_analysis_bkgrnd_Feb5/deglitched/mean_chi_526.mat', 'sally')
apr20.CalcKT()
#+END_SRC

#+RESULTS:

**** TS relation + Tz_i

#+BEGIN_SRC ipython :session    :file images/temp/py30956onU.png
apr20.CompareEstimates('chi', 'mm1', 'mi11');
#+END_SRC
**** Compare with sally's estimate - looks fine.
Reasons for differences:
1. N² drift + my N² is nearly 0 for large chunks of time due to the fitting.
2. different T_z used for masking: +I always use internal.+ I think she's using mooring. There are differnces even if I match her ~min_dTdz=1e-3~
3. She's NaNing some Jq and Kt values by hand.
4. +Her J_q is calculated using 1-min averaged χ, I think. Mine are calculated using instantaneous χ and then averaged.+ Doesn't really matter

#+BEGIN_SRC ipython :session    :file images/temp/py12676SIh.png

apr20.CompareEstimates('chi', 'mm', 'sally1', 86400)
plt.show()
#+END_SRC

#+RESULTS:
[[file:images/temp/py12676SIh.png]]

#+BEGIN_SRC ipython :session    :file images/temp/py12676AyD.png

apr20.CompareEstimates('KT', 'mm', 'sally1', 86400)
#+END_SRC

#+RESULTS:
[[file:images/temp/py12676AyD.png]]

#+BEGIN_SRC ipython :session    :file images/temp/py12676vJw.png

plt.plot_date(apr20.time, apr20.chi['mm1']['N2'].squeeze(),
	      '-', linewidth=1, alpha=0.6)
plt.plot_date(apr20.chi['sally1']['time'].squeeze(),
	      apr20.chi['sally1']['N2'].squeeze(),
              '-', linewidth=1, alpha=0.6)
plt.legend('My N² (tanh fit)', 'sally N2')

#+END_SRC
#+CAPTION: Sally's N² has salinity drift.
#+RESULTS:
[[file:images/temp/py12676vJw.png]]


#+BEGIN_SRC ipython :session    :file images/temp/py17170nPm.png

apr20.Summarize(est='sally1', filter_len=86400)
#+END_SRC

#+BEGIN_SRC ipython :session    :file images/compare-sally-summary.png

est = 'mm'
plt.figure(figsize=(8, 3.5))
plt.subplot(141)
dcpy.plots.hist(apr20.chi[est]['chi'], log=True)
dcpy.plots.hist(apr20.chi['sally1']['chi'], log=True)
plt.title('χ')

plt.subplot(142)
dcpy.plots.hist(apr20.KT[est], log=True)
dcpy.plots.hist(apr20.chi['sally1']['Kt1'], log=True)
plt.title('$K_T$')

plt.subplot(143)
dcpy.plots.hist(apr20.chi[est]['dTdz'], log=True)
dcpy.plots.hist(apr20.chi['sally1']['dTdz'], log=True)
plt.title('$|T_z|$')
plt.legend(('mine', 'sally'))

plt.subplot(144)
dcpy.plots.hist(apr20.Jq[est], log=True)
dcpy.plots.hist(apr20.chi['sally1']['Jq1'], log=True)
plt.title('$|J_q|$')

plt.tight_layout()
plt.show()
#+END_SRC
#+CAPTION: Sally seems to have NaN-ed out certain time instants by hand after using ~min_dTdz = 1e-3~. ~min_dTdz = 2e-3~ might be a good middle ground choice.
#+RESULTS:
[[file:images/compare-sally-summary.png]]

*** 2017-04-12 :noexport:
#+BEGIN_SRC ipython :session

import chipy.chipy as chipy

apr07 = chipy.chipod('../RAMA13/data/', '526', '2017-04-07.mat')
apr07.LoadChiEstimates()
apr07.CalcKT()

apr12 = chipy.chipod('../RAMA13/data/', '526', '2017-04-12.mat')
apr12.LoadChiEstimates()
apr12.CalcKT()
#+END_SRC

#+RESULTS:

#+BEGIN_SRC ipython :session    :file images/chi-mm1-apr07-apr12.png

  window=None

  plt.subplot(2, 1, 1)
  apr07.PlotEstimate('chi', 'mm1', filter_len=window);
  apr12.PlotEstimate('chi', 'mm1', filter_len=window);

  plt.subplot(2, 1, 2)
  lv1 = np.log10(apr07.chi['mm1']['chi'])
  lv2 = np.log10(apr12.chi['mm1']['chi'])

  plt.hist(lv1[np.isfinite(lv1)], bins=40, normed=True, alpha=0.5)
  plt.hist(lv2[np.isfinite(lv2)], bins=40, normed=True, alpha=0.5)
  plt.legend(('apr07', 'apr12'))
  plt.show()

#+END_SRC
#+CAPTION: These χ's are an order of magnitude higher than [[2017-04-07]] because of drift in N²
#+RESULTS:
[[file:images/chi-mm1-apr07-apr12.png]]

Using mooring dT/dz to mask χ masks out 2.7% of estimates
Using internal dT/dz to mask χ masks out 7% of estimates
Using speed < 5cm/s masks out 0.35% estimates

*masking does not change much at all*

The difference is N² but why is χ higher for higher N^2?
\[ k_b ∝ ε_χ ∝ N^2 \]


#+BEGIN_SRC ipython :session    :file images/temp/py12676_n2.png

  plt.plot_date(apr07.chi['mm1']['time'], apr07.chi['mm1']['N2'],
		'-', linewidth=1)
  plt.plot_date(apr12.chi['mm1']['time'], apr12.chi['mm1']['N2'],
		'-', linewidth=1)
  plt.ylabel('N²')
  plt.legend('Apr 07', 'Apr 12')
  plt.show()
#+END_SRC

#+RESULTS:
[[file:images/temp/py12676_n2.png]]

#+CAPTION: For Apr07 estimate, use_TS_slope = 1 i.e. using Johannes' method of fitting T-S slope. For Apr12, I was doing the simple difference.
[[file:images/526-apr7-apr12-N2.png]]
*** 2017-04-07 :noexport:
 | 10-min *unfiltered*  salinity | mooring dT/dz |

#+BEGIN_SRC ipython :session
c526 = chipy.chipod('../RAMA13/data/', '526', '2017-04-07')
c526.LoadChiEstimates()
c526.LoadSallyChiEstimate('../sally/chi_analysis_bkgrnd_Feb5/deglitched/mean_chi_526.mat', 'sally')
#+END_SRC

#+RESULTS:
**** test filtering
#+BEGIN_SRC ipython :session   :file images/temp/py172156XN.png

  w, h = mpl.figure.figaspect(1/1.618)
  plt.figure(figsize=(w,h))
  c526.PlotEstimate('KT', 'mm1')
  c526.PlotEstimate('KT', 'mm1', filter_len=24*60+1)
#+END_SRC

#+RESULTS:
[[file:images/temp/py172156XN.png]]

**** scatter χ vs. velocity

#+BEGIN_SRC ipython :session    :file images/chi-velocity-526.png


#+END_SRC
**** ~mm1~ vs. sally

Seems to agree fine. My estimates tend to be noisier; this is probably because of salinity spiking --- this estimate uses unfiltered 10-min salinity.
#+BEGIN_SRC ipython :session    :file images/chi-526-prelimsal-mm1-sally.png
  w, h = mpl.figure.figaspect(1/1.618)
  plt.figure(figsize=(w,h))
  c526.PlotEstimate('KT', 'mm1', filter_len=24*60+1)
  c526.PlotEstimate('KT', 'sally', filter_len=24*60+1)

#+END_SRC

#+RESULTS:
[[file:images/chi-526-prelimsal-mm1-sally.png]]
**** ~mm1~ vs. ~mm2~
#+BEGIN_SRC ipython :session    :file images/chi-526-prelimsal-mm1-mm2.png
  c526.CompareEstimates('chi', 'mm1', 'mm2', filter_len=24*60+1)
#+END_SRC

#+RESULTS:
[[file:images/chi-526-prelimsal-mm1-mm2.png]]

**** Sally T1 vs. T2
#+BEGIN_SRC ipython :session    :file images/chi-526-sally-mm1-mm2.png
c526.CompareEstimates('chi', 'sally1', 'sally2', filter_len=5*24*6+1)
#+END_SRC

#+RESULTS:
[[file:images/chi-526-sally-mm1-mm2.png]]

**** Distributions

#+BEGIN_SRC ipython :session    :file images/temp/py12676O0V.png

chi = c526.chi['mm1']['chi'][:].squeeze()


#+END_SRC
*** first try :noexport:
**** ~mm1~ and ~mi11~ agree really well.
#+BEGIN_SRC ipython :session    :file images/RAMA13-chi-compare-526-mm1-mi11.png
  c526.CompareEstimates('chi', 'mm1', 'mi11')
#+END_SRC

#+RESULTS:
[[file:images/RAMA13-chi-compare-526-mm1-mi11.png]]

#+BEGIN_SRC ipython :session  :file images/RAMA13-KT-compare-mm1-mi11.png
c526.CompareEstimates('KT', 'mm1', 'mi11')
#+END_SRC

#+RESULTS:
[[file:images/RAMA13-KT-compare-mm1-mi11.png]]

**** ~mi11~ and ~mi22~ disagree quite a lot!
#+BEGIN_SRC ipython :session    :file images/RAMA13-chi-compare-526-mi11-mi22.png

c526.CompareEstimates('chi', 'mi11', 'mi22')

#+END_SRC

#+RESULTS:
[[file:images/RAMA13-chi-compare-526-mi11-mi22.png]]
#+BEGIN_SRC ipython :session  :file images/RAMA13-kt-compare-526-mi11-mi22.png

c526.CompareEstimates('KT', 'mi11', 'mi22')

#+END_SRC

#+RESULTS:
[[file:images/RAMA13-kt-compare-526-mi11-mi22.png]]

**** ~mi11~ and ~pi11~ agree well - but pitot voltage drifts!
This is with the 40-day high pass filtered pitot but I forgot to add back the 40-day mean.

#+BEGIN_SRC ipython :session    :file images/RAMA13-chi-compare-526-mi11-pi11.png

c526.CompareEstimates('chi', 'mi11', 'pi11', filter_len=24*60)

#+END_SRC

#+RESULTS:
[[file:images/RAMA13-chi-compare-526-mi11-pi11.png]]

#+BEGIN_SRC ipython :session  :file images/RAMA13-kt-compare-526-mi11-pi11.png

c526.CompareEstimates('KT', 'mi11', 'pi11', filter_len=24*60)

#+END_SRC

#+RESULTS:
[[file:images/RAMA13-kt-compare-526-mi11-pi11.png]]

**** masking

#+BEGIN_SRC ipython :session  :file images/temp/py172156XN.png

  chi = c526.chi['mi11']
  N2 = chi['N2'][:].squeeze()
  Tz = chi['dTdz'][:].squeeze()
  c = chi['chi'][:].squeeze()

  c[Tz < -0.5] = np.nan
  c[N2 > 1] = np.nan
  plt.plot(c)
  plt.yscale('log')

  import scipy.ndimage as image

  def dcmedianfilter(a):
    return np.nanmedian(a)

  # cfilt = image.generic_filter1d(c, dcmedianfilter, 10)
  cfilt = image.median_filter(c, 5*24*60)
  plt.plot(c, '-')
  plt.plot(cfilt, '-')
  plt.yscale('log')
#+END_SRC

#+RESULTS:
[[file:images/temp/py172156XN.png]]
** χ-pod 527

#+CAPTION: Pitot tube dies in June and temperature dies by October  (;´༎ຶД༎ຶ`)
[[file:~/rama/RAMA13/quick_summary/527/summary1_527.png]]

#+BEGIN_SRC ipython :session
import chipy.chipy as chipy
import importlib
chipy = importlib.reload(chipy)

c527 = chipy.chipod('../RAMA13/data/', '527', '2017-04-20.mat', best='mm')
#+END_SRC

#+RESULTS:

+zoom-in on "weird" stuff+ - this was because dT/dz masking was not right
#+BEGIN_SRC ipython :session :file images/temp/py2766pu1.png
chipy = importlib.reload(chipy)

c527 = chipy.chipod('../RAMA13/data/', '527', 'Turb.mat', best='mm1')
c527.LoadT1T2()
c527.Summarize(filter_len=86400)
#+END_SRC

#+RESULTS:
[[file:images/temp/py2766pu1.png]]

#+BEGIN_SRC ipython :session :file images/temp/py17346D9Q.png

c527.CompareEstimates('chi', 'mm1', 'mm2', filter_len=3600)

#+END_SRC

#+RESULTS:
[[file:images/temp/py17346D9Q.png]]

#+BEGIN_SRC ipython :session :file images/temp/py12676zpc.png
c527.CompareEstimates('KT', 'mm1', 'mm2', filter_len=None)
#+END_SRC

#+RESULTS:
[[file:images/temp/py12676zpc.png]]


#+BEGIN_SRC ipython :session :file images/temp/py12676aIv.png
c527.CompareEstimates('KT', 'pm1', 'pm2', filter_len=86400)
#+END_SRC

#+RESULTS:
[[file:images/temp/py12676aIv.png]]
* RAMA14 (ra-122)

 [[file:images/rama1314-T-s-ρ.png]]

* what χ estimates are independent?

I think it makes most sense to keep the different ∂T/∂z based estimates apart. I can average T1, T2 based estimates that use the same ancillary data.

-----

~T1~, ~T2~ are independent measures of the "same thing."

internal ∂T/∂z and mooring Tz are independent measures of the temperature stratification

for *526*: always mooring velocity, mooring N²
- ~mm1~
- ~mm2~
- ~mi11~
- ~mi22~

for *527*: always pitot velocity, mooring N²
- ~pm1~
- ~pm2~
- ~pi11~
- ~pi22~

Can I choose between mooring and internal dT/dz? They are /independent/ measures of ∂T/∂z
 - But you have to worry about which one is more appropriate especially when salinity is so important.
* Stratification bias

The Batchelor wavenumber appears to be a strong constraint on the fit; and it is unfortunately quite sensitive to relative magnitudes of N² and ∂T/∂z.

Lessons:
1. Use consistent ∂T/∂z and N².
2. /Somehow/, T-S relation seems to work decently well.

-----

#+CAPTION: Averaging the 1s spectra over increasing intervals. χ estimate converges for n ≥ 5. Converged estimate is factor of 2 higher than initial 1s estimate. Using internal dT/dz results in χ that is factor of 3 higher than mooring dT/dz.
[[file:images/chi-fit-averaged-spectra.png]]

It appears that if I use N² and ∂T/∂z at different scales, then that biases the calculation of χ quite significantly.

Using mooring N² and different ∂T/∂z results in biased PDF for χ (see two examples below)
#+ATTR_HTML: :width 80%
[[file:images/chi-same-N2-diff-dTdz-2.png]]
#+ATTR_HTML: :width 80%
[[file:images/chi-same-N2-diff-dTdz.png]]


#+CAPTION: Changing T_z (here halved and doubled) changes k_b which shifts the spectrum. Associated χ values are [5e-9, 1.7e-9, 7e-10] for [T_z/2, T_z, T_z*2].
[[file:images/chi-fit-Tz-sensitivity.png]]

#+CAPTION: Changing N² (here halved and doubled) changes k_b which shifts the spectrum
[[file:images/chi-fit-N2-sensitivity.png]]

#+CAPTION: Ratio of Tz_i/Tz_m seems to be large enough that estimates will be biased.
[[file:images/Tz-i-m-ration.png]]
*** χ fitting

- the inner loop (count) runs a lot on the first iteration; after that it only runs twice at most. This initial run is probably what biases ε

- dff
* Bad fits

Emily's suggestion of looking at N²/T_z² is better!

ε basically follows that ratio. A limit of 1e4 seems to work quite well.
[[file:images/hudhud-N2-Tz-filtering.png]]

** IC stuff (not good)

Below is wrong. It shouldn't matter what range we are in. Better to look at $N²/T_z²$ which determines $ε, k_b$ → these really control the fit.

There are quite a *lot* of fits that look like:
#+CAPTION: vertical lines are k_{start}, k_{stop}, k_{i}, k_{b}
[[file:images/526-bad-fit.png]]

The fit thinks the data are in the /inertial-convective/ range but we want to be in the /viscous-convective/ or /viscous-diffusive/ ranges.

Using k_i to denote wavenumber end of inertial-convective, I impose k_i < k_{start} or k_i < k_{stop}; /start, stop/ being the range within which the fit is checked.
#+CAPTION: A lot of high-ε estimates are thrown out if we get rid of fits in the IC range. The histograms are raw counts.
[[file:images/526-chi-ki-filtering.png]]

#+CAPTION: Full masking results.
[[file:images/526-masking.png]]
* Sally's processing:
1s estimate -> min_dTdz=1e-4 -> 1 minute averages
